---
title: "Plotting Omics Data"
author: "Jiratchaya Nuanpirom"
date: "17 May 2023"
format:
  html:
    toc: true
    number-sections: true
    number-depth: 3
    code-annotations: hover
execute: 
  eval: true
  echo: true
  warning: false
bibliography: references.bib
---


## Plotting Abundance of Representative Terms

```{r, fig.height=5, fig.width=7}
#| tbl-cap: "First 10 lines of the number of COG category results."

# Load libraries
pacman::p_load(
  "tidyverse",
  "kableExtra",
  "openxlsx"
)


# Load COG dictionary
COG_dict <- read_delim("https://github.com/JirathNuan/r-handviz-workshop/raw/main/datasets/cog_category.txt")   # <1>

# Load eggNOG-mapper result
emapper_dt <- read.xlsx("https://github.com/JirathNuan/r-handviz-workshop/raw/main/datasets/Dme_chr4.emapper.annotations.xlsx",    # <2>
                        startRow = 3, 
                        cols = 7) %>% 
  filter(COG_category != "-") %>%                               # <3>
  group_by(COG_category) %>%                                    # <4>
  summarize(n = n()) %>%                                                   # <5>
  left_join(COG_dict, by = c("COG_category" = "category")) %>%     # <6>
  mutate(label = paste0(COG_category, ": ", category_name))     # <7>

# Show first 10 lines of data frame
head(emapper_dt, 10) %>% kbl() %>% kable_styling(full_width = FALSE)
  
# Plot
ggplot(emapper_dt, aes(x = COG_category, y = n, fill = label)) +  # <8>
  geom_bar(stat = "identity") +                                 # <9>
  scale_y_continuous(breaks = seq(0, 100, 10)) +                # <10>
  labs(x = "COG category",                                      # <11>
       y = "Number of sequences", 
       fill = "COG category") +
  theme(legend.key.size = unit(0.5, 'cm'))                      # <12>
```

1.  `cog_category.txt` is a cluster of orthologous groups (COG) dictionary. Use for look up the category names into the plot.

2.  Read eggNOG-mapper result from excel file into `emapper_dt`, using `read.xlsx()` from openxlsx library. The excel is read by skipping the first 3 rows and select only 7th column.

3.  Then, go to the next step by pipe `%>%`. This step it to filter unclassified COGs `-` from the `COG_category` using dplyr `filter()`.

4.  Then group the data frame by `COG_category`.

5.  Count number of COGs presented in this eggNOG-mapper result.

6.  Merge COG dictionary into the result using dplyr `left_join()`. Two data frames are merged by matching the column `COG_category` from `emapper_dt` with the column `category` of `COG_dict`.

7.  Then, add new column `label` for the plot legend, by append COG category together with the category name.

8.  Plot the result from by showing `COG_category` in x-axis, number of COGs `n` in y-axis, fill and add legend by column `label`.

9.  Plot bar plot using `geom_bar()` and `stat = "identity"`

10. Set y-axis breaks

11. Customize label of x- and y-axis, and legend name in `fill`.

12. Adjust size of legend using `theme(legend.key.size)`.

## Principal Component Analysis

We will demonstrate PCA on a *pasilla* data set [@brooks2010]. This data set was obtained from an experiment on *Drosophila melanogaster* cell cultures that investigated the effects of knocking down the splicing factor *pasilla* using RNAi.


```{r}
#| fig-width: 6
#| fig-height: 4

# Load libraries
pacman::p_load(
  "tidyverse",
  "DESeq2",
  "kableExtra",
  "pcaExplorer",
  "factoextra",
  "ggsci"
)

# Load data set
cts <- read_delim("https://raw.githubusercontent.com/JirathNuan/r-handviz-workshop/main/datasets/cts.tsv")

# Prepare DESeq input, which is expecting a matrix of integers.
de_input <- as.matrix(cts[,-1])
row.names(de_input)<- cts$transcript_name
# Remove NAs
de_input <- de_input[complete.cases(de_input), ]

# Show first 10 rows of the matrix
head(de_input, 10) %>% kbl() %>% kable_styling(full_width = FALSE)

# Create an experimenta design data frame
coldata <- data.frame(sample = colnames(de_input),
                      sample_group = gsub("[0-9]", "", colnames(de_input)))

# Show how experimental data looks like
coldata %>% kbl() %>% kable_styling(full_width = FALSE)


# Create DESeq object by load matrix and experimental design
dds <- DESeqDataSetFromMatrix(countData = de_input,
                              colData = coldata,
                              design= ~ sample_group)

# Perform differential expression analysis
dds <- DESeq(dds)

# Create a normalized matrix of cts data set
cts_norm <- counts(dds, normalized = TRUE)

# Show how the data looks like
head(cts_norm) %>% kbl()
```

```{r}
#| fig-width: 7
#| fig-height: 4.5
# Plot PCA With pcaExplorer
rld_dds <- rlogTransformation(dds)
pca_dds <- pcaplot(rld_dds, 
                     intgroup = "sample_group", 
                     ntop = Inf,
                     pcX = 1,
                     pcY = 2)
pca_dds
```


```{r}
#| fig-width: 7
#| fig-height: 4.5
# Scree plot
pcaobj_dds <- prcomp(t(assay(rld_dds)))

# Visualizing scree plot
fviz_eig(pcaobj_dds, 
         addlabels = TRUE, 
         barfill = pal_npg()(1),
         barcolor = "black",
         title = "Proportion of explained proportion of variance - cts data set",
         ggtheme = theme_gray())
```
Extracting the top principal components

```{r}
# extract the table of the genes with high loadings
top100_pc <- hi_loadings(pcaobj_dds,
                         topN = 100,
                         exprTable = counts(dds))

# Show how experimental data looks like
head(top100_pc) %>% kbl() %>% kable_styling(full_width = FALSE)

```

Biplot using `genespca()`

`genespca()` computes and plots the principal components of the genes, eventually displaying the samples as in a typical biplot visualization. This is the function in action for the Genes View tab.

```{r}
groups_cts <- colData(dds)$sample_group

cols_cts <- scales::hue_pal()(2)[groups_cts]

# with many genes, do not plot the labels of the genes
genespca(
  rld_dds,
  ntop = 100,
  choices = c(1, 2),
  arrowColors = cols_cts,
  groupNames = groups_cts,
  useRownamesAsLabels = FALSE,
  varname.size = 5,
  biplot = TRUE,
  alpha = 0.5,
  point_size = 2.5
)

```
Plots the distribution of expression values, either with density lines, boxplots or violin plots.

```{r}
#| layout-ncol: 3
distro_expr(rld_dds, plot_type = "violin") + 
  scale_fill_npg() + 
  scale_color_npg()

distro_expr(rld_dds, plot_type = "boxplot") + 
  scale_fill_npg() + 
  scale_color_npg()
```


## Hierarchical Clustering Analysis (Heat maps)

We'll demonstrate on the same data set. 

```{r}
# Create annotation column
annot_column <- data.frame(sample = colnames(top100_pc),
                           group = gsub("[0-9]", "", colnames(top100_pc))) %>% 
  column_to_rownames(var = "sample")

annot_column %>% kbl()

# Create a list of annotation color
sample_pal <- pal_npg()(2)
annot_colors <- list(group = c(treated = sample_pal[1],
                               untreated = sample_pal[2]))
```


```{r}
#| fig-width: 3
#| fig-height: 5
# Load libraries
pacman::p_load(
  "ComplexHeatmap",
  "RColorBrewer"
)

# Heatmap of the top 100 principal components
hm_top100pc <- pheatmap(
  top100_pc,
  scale = "row",
  color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
  show_rownames = FALSE,
  name = "Normalized count",
  clustering_distance_rows = "euclidean",
  clustering_distance_cols = "euclidean",
  clustering_method = "complete",
  annotation_col = annot_column,
  annotation_names_col = FALSE,
  annotation_colors = annot_colors,
  cutree_rows = 3,
  annotation_legend = FALSE
)
hm_top100pc
```

Heatmap of differentially expressed genes

```{r}
# Identify differentially expressed genes
dds_result <- results(object = dds,
                      contrast = c("sample_group", "untreated", "treated"),
                      tidy = TRUE,
                      pAdjustMethod = "fdr")
```

Filter DEG, we'll use absolute log2FC > 1 and FDR < 0.05

```{r}
#| fig-width: 3
#| fig-height: 5
dds_result_deg <- dds_result %>% 
  filter(padj < 0.05 & abs(log2FoldChange) > 1)

# Extract count matrix of DEGenes
deg_norm_count <- cts_norm[rownames(cts_norm) %in% dds_result_deg$row, ]

# Plot heatmap of DEGs
# Heatmap of the top 100 principal components
hm_deg <- pheatmap(
  deg_norm_count,
  scale = "row",
  color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
  show_rownames = FALSE,
  name = "Normalized count",
  clustering_distance_rows = "euclidean",
  clustering_distance_cols = "euclidean",
  clustering_method = "complete",
  annotation_col = annot_column,
  annotation_names_col = FALSE,
  annotation_colors = annot_colors,
  cutree_rows = 2,
  annotation_legend = FALSE)
hm_deg
```


## Volcano Plot

```{r}
pacman::p_load(
  "EnhancedVolcano"
)

volcano_deg <- dds_result %>% 
  mutate(Expression = case_when(
      log2FoldChange >= 1 & padj <= 0.05 ~ "Upregulated",
      log2FoldChange <= -1 & padj <= 0.05 ~ "Downregulated",
      TRUE ~ "Unchanged"))

p_volcano <- EnhancedVolcano(
  volcano_deg,
  lab = volcano_deg$row,
  x = 'log2FoldChange',
  y = 'padj',
  xlim = c(-5,5),
  ylab = bquote( ~ -Log[10] ~ italic(FDR)),
  title = NULL,
  caption = NULL,
  subtitle = NULL,
  pCutoff = 0.05,
  pointSize = 3,
  labSize = 3,
  col = c("grey50", "dodgerblue3", "dodgerblue3", "firebrick2"),
  legendLabels = c("NS", 
                   expression(abs(log[2] ~ FC) > 1),
                   "FDR < 0.05",
                   expression(Pvalue < 0.05 ~ and ~ abs(log[2] ~ FC) > 1))) +
  theme_minimal() +
  theme(legend.position = "bottom",
        panel.border = element_rect(fill = NA, color = "black"),
        panel.grid = element_blank())


p_volcano
```


## Venn Diagram and Upset Plot

### Plotting venn diagram with `ggvenn`

```{r}
# Load library
pacman::p_load("ggvenn", "ggsci")

# Load data
mouse_hallmarks <- read_delim("../datasets/mouse_msigdb_6hallmarks.txt")

# Split into list
lst_mouse_hallmark <- as.list(mouse_hallmarks)
# remove NAs
lst_mouse_hallmark <- lapply(lst_mouse_hallmark, na.omit)

# Chart
ggvenn(
  lst_mouse_hallmark, 
  fill_color = pal_npg()(6),
  stroke_size = 0.5, 
  set_name_size = 3
  )

```

### Venn diagram alternative: Upset Plot

```{r}
# Load libraries
pacman::p_load("ComplexHeatmap")

set.seed(123)

# Make present-absent matrix of data list
mouse_hm_mat01 <- list_to_matrix(lst_mouse_hallmark)
# Show how the combination matrix looks like
head(mouse_hm_mat01) %>% kbl()

# Make the combination matrix
comb_mat <- make_comb_mat(lst_mouse_hallmark)
comb_mat
```

The default mode of combination matrix is 'distinct'.
blah


```{r}
pal_upset <- pal_npg()(4)
# Plot upset following the default upset mode.
upset_mouse_hm <-
  UpSet(
    comb_mat,
    comb_col = pal_upset[1],
    row_names_gp = gpar(fontsize = 10),
    right_annotation = upset_right_annotation(
      comb_mat,
      gp = gpar(fill = pal_upset[2]),
      add_numbers = TRUE
    ),
    top_annotation = upset_top_annotation(
      comb_mat,
      gp = gpar(fill = pal_upset[1]),
      add_numbers = TRUE
    )
  )
upset_mouse_hm
```





## ggplot2 Based Publication Ready Plots with `ggpubr`

```{r}
pacman::p_load(
  "ggpubr",
  "ggsci",
  "kableExtra"
)

# Load dataset
mouseLiver_ctg <- read_csv("../datasets/mouseLiver_data_ClinicalTraits.csv")

# Inspect the data
head(mouseLiver_ctg) %>% kbl()

```

### Histogram

```{r}
gghistogram(
  mouseLiver_ctg,
  x = "weight_g",
  add = "mean",
  rug = TRUE,
  color = "sex",
  fill = "sex",
  bins = 30,
  palette = "npg",
  xlab = "Weight (g)",
  ylab = "Frequency"
)
```
### Density plot 

```{r}
ggdensity(
  mouseLiver_ctg,
  x = "weight_g",
  add = "mean",
  rug = TRUE,
  color = "sex",
  fill = "sex",
  palette = "npg",
  xlab = "Weight (g)",
  ylab = "Frequency"
)
```

### Simple box plot

```{r}
p_boxplot <- ggboxplot(ToothGrowth, x = "supp", y = "len",
          color = "supp", palette = "npg",
          add = "jitter",
          xlab = "Supplement type",
          ylab = "Tooth length")
p_boxplot
```

Adding statistical significance to the plot

- Pairwise comparison

```{r}
#| layout-ncol: 2
# Try to calculate stat first
compare_means(len ~ supp, data = ToothGrowth, method = "anova")
compare_means(len ~ supp, data = ToothGrowth, method = "wilcox.test")

# Plot box plot with significance
p_boxplot + stat_compare_means(method = "anova")
p_boxplot + stat_compare_means(method = "wilcox.test")

# Change style of singnificance notation
p_boxplot + stat_compare_means(method = "anova",
                               aes(label = ..p.signif..),
                               label.x = 1.5,
                               label.y = 40)

p_boxplot + stat_compare_means(method = "wilcox.test",
                               aes(label = "p.signif"),
                               label.x = 1.5,
                               label.y = 40)
```


- Compare more than two groups

```{r}
#| layout-ncol: 2
# Global test
compare_means(len ~ dose,  data = ToothGrowth, method = "anova")

# Default method = "kruskal.test" for multiple groups
ggboxplot(ToothGrowth, x = "dose", y = "len",
          fill = "dose", palette = "npg")+
  stat_compare_means()

# Change method to anova
ggboxplot(ToothGrowth, x = "dose", y = "len",
          fill = "dose", palette = "npg")+
  stat_compare_means(method = "anova")
```
```{r}
# Perorm pairwise comparisons
compare_means(len ~ dose,  data = ToothGrowth)

# Visualize: Specify the comparisons you want
my_comparisons <- list(c("0.5", "1"), c("1", "2"), c("0.5", "2"))

ggboxplot(
  ToothGrowth,
  x = "dose",
  y = "len",
  fill = "dose",
  palette = "npg") +
  stat_compare_means(comparisons = my_comparisons) + # Add pairwise comparisons p-value
  stat_compare_means(label.y = 50)     # Add global p-value
```

- Multiple pairwise tests against a reference group

```{r}
# Pairwise comparison against reference
compare_means(len ~ dose,
              data = ToothGrowth,
              ref.group = "0.5",
              method = "t.test")

# Visualize
ggboxplot(
  ToothGrowth,
  x = "dose",
  y = "len",
  fill = "dose",
  palette = "npg") +
  stat_compare_means(method = "anova", label.y = 40) +      # Add global p-value
  stat_compare_means(label = "p.signif",
                     method = "t.test",
                     ref.group = "0.5")                    # Pairwise comparison against reference
```

Multiple grouping variables

```{r}
compare_means(len ~ supp, data = ToothGrowth, group.by = "dose")

# Box plot facetted by "dose"
p_box <- ggboxplot(
  ToothGrowth,
  x = "supp",
  y = "len",
  color = "supp",
  palette = "jco",
  add = "jitter",
  facet.by = "dose",
  short.panel.labs = FALSE
)
# Use only p.format as label. Remove method name.
p_box + stat_compare_means(label = "p.format")
```

### Bar and line plots (one grouping variable):

```{r}
#| layout-ncol: 2
ggbarplot(
  ToothGrowth,
  x = "dose",
  y = "len",
  add = "mean_se",
  fill = "supp",
  palette = "npg",
  color = "black",
  position = position_dodge(0.8)) +
  stat_compare_means(aes(group = supp), label = "p.signif", label.y = 29)

ggline(
  ToothGrowth,
  x = "dose",
  y = "len",
  add = "mean_se",
  color = "supp",
  palette = "npg") +
  stat_compare_means(aes(group = supp),
                     label = "p.signif",
                     label.y = c(16, 25, 29))
```

### Scatter plot

```{r}
p4 <- ggscatter(
  mtcars,
  x = "wt",
  y = "mpg",
  fill = "mpg",
  size = 4,
  shape = 21) +
  gradient_fill(c("blue", "white", "red"))
p4

```



## Session info

```{r}
sessionInfo()
```
